# 프론트 이슈별 정리

## SSR은 왜 필요한가?

1. **page back을 사용하기 위함이다.** React에서 CSR 렌더 웹앱은 페이지를 뒤로가기 후 다시 돌아오면 데이터가 날라가 있다. `NextJS`는 page back 할때 현재뷰의 바로 위에 다른 뷰를 출력시켜 마치 이전 뷰가 사라진 것 처럼 보이게 할때 쓰는 라이브러리 혹은 모듈 이라고 한다.

2. **검색엔진 최적화(SEO)하기 위한 방법이다.**. CSR은 DOM이 그려진 이후 데이터가 삽입되기 때문에 검색엔진에서 불리하다. SSR은 JS로 프로그래밍 된 NodeJS기반 서버에서 컴포넌트 페이지를 그려서 넘겨주기 때문에 검색엔진에 유리하다.

3. React SSR 이슈. React를 SSR 하는 방법은 세 가지가 있다.
   - Create-React-App/Gatsby/NextJS
   - 앞에 두개는 독립적으로 이용하나 NextJS는 Express에 플러그인을 꼽아 사용한다.

## JavaScript 이슈

- JavaScript 객체지향 이슈. Javascript는 엄연히 객체 지향이다. 모든 변수를 Object로 인식하나 처음 변수 선언 시 초기화 타입에 따라 내부적으로 new String()를 호출하며 새로운 메모리를 할당한다. 그러나 새 변수에 이전 변수를 할당하면 새 변수는 새로운 메모리를 할당받지 않은 `참조용 변수`가 된다.

- JS가 객체지향인 덕분에 함수의 매개변수로 함수를 받을 수 있다. 변수, 함수 등 Javascript는 **모든 데이터를 객체 타입으로 다루고 있음을 잊지말자.**

- 상위호환 `TypeScript`를 도입하는 이슈. Object기반의 js가 프로그래밍은 편하겠지만 런타임에서 타입 validation 에러가 날 수 있다. 그래서 변수의 타입을 명시할 수 있는 언어가 TypeScript 이다. js의 상위 언어여서 번들링 하기 전 javascript로 변환되는 '트랜스파일링'이 일어난다. 타입 에러가 있을 경우 이 트랜스파일링에서 에러가 검출된다.

- hook방식은 코드의 양을 줄여준다.

- 네이밍규칙을 활용하면 많은 양의 클래스 혹은 컴포넌트에 hook을 걸 수 있다. prefix를 사용해서 말이다. 예를들어 \_code, \_xml, \_Auth와 같이 말이다. validation을 확인하고 console을 출력하는 모듈을 만들면 웹 페이지 양이 늘어나도 에러를 효율적으로 모니터링 할 수 있다.

- JS에서도 class를 만들 수 있지만 컴파일 부담이 있어 function을 사용한다.

## 브라우저와 웹 동작 이슈

- React 인터프리터 이슈. Java의 경우 컴파일을 해야하므로 엔진이 필요하다. JS의 경우 인터프리터, 즉 통역사 역할을 하는 엔진이 내장되어 있어 DOM을 render 한다. 그래서 js코드는 브라우저가 읽고 바로바로 바이너리로 바꾼다. JS를 컴퓨터에서 이해시킬 수 있게 하는 엔진이 NodeJS 다. (Ionic,electron)

- ActiveX는 샌드박스 바깥으로 튀어나갈 수 있게 해준다. 브라우저는 한 샌드박스 안에 있는데 그 밖의 영역으로 제어가 나오지 않는다.

## React 이슈

- Redux, Mobx(프레임워크 상태)를 도입하는 이슈. event를 한번에 감시하게 하는 기능이 있다. 예를들어 여러 input의 데이터를 하나씩 감시할게 아니라 개발자는 redux에 프로그래밍 하여 event에 대해 여러 요소의 데이터를 감시할 수 있다고 한다.

- Component 단위 이슈. 어떤 단위로 컴포넌트를 구성해야 할까? 컴포넌트가 많거나 렌더링 과정이 복잡해질수록 코드를 구현하는데 부담이 커진다. Reuse 가능성을 고려하라. 구현할 페이지가 적다면 컴포넌트를 크게 잡기도 한다. 한마디로 컴포넌트 단위는 상황에 맞게 구성되어야 한다.

- React Styling 이슈. React에서 css의 스타일을 입히는 방법은 두가지가 있다. 코드가 많으면 CSS In Js로 가면 관리가 편하다.
